[TOC]



# 三.多表查询

## 一.引入

### 1.多表

通过建立多个表来去除**冗余数据**导致的大量无效空间被占用，以及便于归类和查询。但多个表的查询需要**多表查询**的语句。

### 2.笛卡尔积错误

**笛卡尔积**（又称**交叉连接**）错误，会导致大量重复无效数据。如在行数为n的表和行数为m的表中，同时查询第一个表的某一字段和第二个表中与其对应的字段，会导致查询出**m*n**条数据。

如：

```mysql
SELECT employee_id,department_name FROM employees,departments;
SELECT employee_id,department_name FROM employees CROSS JOIN departments;
```

则输出时，每个employee_id将与departments表中的每一个department_name都对应一遍，导致出现**m*n**个字段。

## 二.多表查询

### 1.连接条件

**通过增加连接条件，可以减少重复数据。**

```mysql
SELECT employee_id,department_name FROM employees,departments WHERE employees.`department_id` = departments.department_id;
```

```WHERE```语句限定了，只有当employees表中的department_id和departments表中的department_id相等时，才会将这一行输出。



通过限定对应表的相交部分的数据（即**连接条件**）相等，来限定输出字段的内容，防止**笛卡尔积错误**。

```mysql
SELECT e.employee_id,e.last_name,d.department_name,l.city,e.department_id,l.location_id FROM employees e,departments d,locations l WHERE e.`department_id` = d.`department_id` AND d.`location_id` = l.`location_id`;
```

上述语句实现了三个表的重命名，并用```WHERE```限制了输出。

其中的限制条件为

```mysql
WHERE e.`department_id` = d.`department_id` AND d.`location_id` = l.`location_id`;
```

==注==：**若有n个表需要多表查询，则需要至少n-1个连接条件。**



### 2.Ambigous错误

当一个字段在多个表中都存在时，会导致**Ambigous错误**，即没有指明输出哪个表中的数据。

**解决方法：**

在字段前加入对应表的名称

```mysql
SELECT employees.department_id FROM employees,departments;
```

此时即指明了输出的数据应为employees表中的department_id列的数据。



### 3.表的别名

给表起别名时，可以减少表输入时的字符输入量，便于输入。

```mysql
SELECT emp.employee_id,dept.department_name,emp.department_id FROM employees emp,departments dept WHERE emp.`department_id` = dept.department_id;
```

上述语句给**employees**起了**emp**的别名，给**departments**起了**dept**的别名。

但==注意==，一旦给表起了别名，就必须在**SELECT**和**WHERE**中使用其别名，不能再使用其原名。
